// This file extends the main content with ALL remaining topics from the syllabus
// It follows the exact structure provided in the requirements

export const ExtendedCSSContent = {
  "CSS Border Properties": [
    {heading: "border-style", content: "The border-style property sets the style of an element's border. It is required for borders to display - without it, no border appears regardless of width or color settings. Values include: none (no border, default), solid (single solid line), dashed (series of dashes), dotted (series of dots), double (two parallel lines), groove (3D grooved effect), ridge (3D ridged effect), inset (3D inset effect), outset (3D outset effect), and hidden (same as none but used in table border conflicts).", syntax: ".box { border-style: solid; }\n.dashed { border-style: dashed; }\n.mixed { border-style: solid dashed dotted double; }", explanation: "Can specify 1-4 values for different sides. Without border-style, no border renders even if width and color are set."},
    {heading: "border-width", content: "The border-width property sets the thickness of borders. Values can be predefined keywords (thin, medium, thick) or specific lengths (px, em, rem). Can specify 1-4 values for different sides following the same pattern as margin/padding. Default is 'medium'. Width only takes effect if border-style is set.", syntax: ".box { border-style: solid; border-width: 2px; }\n.thick { border-width: 5px 10px 15px 20px; }", explanation: "One value applies to all sides. Two values: vertical then horizontal. Three values: top, horizontal, bottom. Four values: clockwise from top."},
    {heading: "border-color", content: "The border-color property sets the color of borders. Accepts any valid CSS color value. If not specified, defaults to the element's text color (currentColor). Can specify 1-4 values for different sides. Only visible if border-style is set.", syntax: ".box { border-style: solid; border-color: red; }\n.multi { border-color: red green blue yellow; }", explanation: "Follow same multi-value pattern as other border properties. Color only shows when border-style creates a visible border."},
    {heading: "border Shorthand", content: "The border property is a shorthand that sets width, style, and color for all four borders at once. Style is required; width and color are optional. Order doesn't strictly matter but convention is: width, style, color. This is the most common way to add simple borders.", syntax: ".box { border: 2px solid black; }\n.simple { border: solid red; }\n.thin { border: 1px dashed #ccc; }", explanation: "Most concise way to add borders. Sets all four sides identically. For different sides, use border-top, border-right, border-bottom, border-left."},
    {heading: "border-radius", content: "The border-radius property rounds the corners of an element's border. Essential for modern web design. Values in px, %, or em. Can specify 1-4 values for different corners. Using 50% on square elements creates perfect circles. Can create elliptical corners with two values per corner (horizontal-radius vertical-radius).", syntax: ".rounded { border-radius: 10px; }\n.circle { width: 100px; height: 100px; border-radius: 50%; }\n.custom { border-radius: 10px 20px 30px 40px; }", explanation: "One value rounds all corners equally. Four values: top-left, top-right, bottom-right, bottom-left. 50% creates circles from squares."}
  ],
  "CSS Display Property": [
    {heading: "display: block", content: "Block-level elements take up the full width available and start on a new line. They stack vertically. Respect all margin, padding, width, and height properties. Common block elements: div, p, h1-h6, section, article, header, footer.", syntax: ".block { display: block; width: 50%; margin: 10px; padding: 20px; }", explanation: "Block elements create new lines before and after. Can set width/height. Take full width by default even if content is narrower."},
    {heading: "display: inline", content: "Inline elements only take up as much width as necessary and do not start on a new line. They flow with text content. Width and height properties have no effect. Top and bottom margins/paddings don't push other elements away vertically. Common inline elements: span, a, strong, em, img.", syntax: ".inline { display: inline; padding: 5px 10px; margin: 0 5px; }", explanation: "Inline elements flow like words in a sentence. Can't set width/height. Only horizontal spacing fully works."},
    {heading: "display: inline-block", content: "Combines features of both inline and block. Elements flow inline but respect width, height, and all spacing properties. Perfect for creating horizontal layouts while maintaining control over dimensions. Commonly used for navigation menus, button groups, and card layouts.", syntax: ".inline-block { display: inline-block; width: 200px; height: 100px; margin: 10px; vertical-align: top; }", explanation: "Best of both worlds: flows inline but acts like block for sizing. Gap between inline-blocks can appear due to whitespace in HTML."},
    {heading: "display: none", content: "Completely removes the element from the document flow. Takes up no space and is not rendered. Different from visibility: hidden which hides but preserves space. Commonly used for hiding elements, dropdowns, modals until triggered by JavaScript or CSS hover/focus states.", syntax: ".hidden { display: none; }\n.parent:hover .hidden { display: block; }", explanation: "Element is removed from layout calculation entirely. Use for show/hide functionality. JavaScript can toggle between display: none and display: block/inline/etc."},
    {heading: "display: flex", content: "Creates a flexible box layout. Element becomes a flex container and direct children become flex items. Provides powerful one-dimensional layout capabilities (row or column). Enables easy alignment, distribution, and ordering. Modern standard for creating flexible, responsive layouts.", syntax: ".flex-container { display: flex; justify-content: space-between; align-items: center; gap: 10px; }", explanation: "Flexbox simplifies many layout tasks. Items can grow, shrink, and reorder. Great for navigation bars, card layouts, and centering content."},
    {heading: "display: grid", content: "Creates a grid layout system. Element becomes a grid container and direct children become grid items. Provides powerful two-dimensional layout capabilities with rows and columns. Best for complex page layouts, galleries, and structured content.", syntax: ".grid-container { display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; }", explanation: "CSS Grid excels at two-dimensional layouts. Can define explicit rows and columns. Items can span multiple cells."}
  ]
};

export const ExtendedJavaScriptContent = {
  "Applications of JavaScript": [
    {heading: "Web Development", content: "JavaScript's primary use is creating interactive web pages. It manipulates DOM elements, handles user interactions (clicks, hovers, typing), validates forms before submission, creates animations and transitions, dynamically updates content without page reloads, and powers modern single-page applications (SPAs). Every interactive feature on websites uses JavaScript."},
    {heading: "Web Applications", content: "Complex web applications like Gmail, Google Maps, Facebook, Netflix, and Trello rely heavily on JavaScript. Frameworks and libraries like React, Angular, Vue.js, and Svelte enable building sophisticated user interfaces. JavaScript handles client-side routing, state management, real-time updates via WebSockets, and rich user interactions."},
    {heading: "Server-Side Development", content: "Node.js allows JavaScript to run on servers, enabling full-stack JavaScript development. Developers can use the same language for frontend and backend. Node.js is used for REST APIs, GraphQL servers, real-time applications (chat, collaborative tools), microservices architecture, server-side rendering (SSR) for faster initial page loads, and command-line tools."},
    {heading: "Mobile Applications", content: "JavaScript frameworks enable native mobile app development. React Native compiles to native iOS and Android components. Ionic and Framework7 create hybrid apps. NativeScript provides direct access to native APIs. Progressive Web Apps (PWAs) use JavaScript to provide app-like experiences in browsers with offline support and push notifications."},
    {heading: "Desktop Applications", content: "Electron framework enables building cross-platform desktop applications using web technologies. Popular apps built with Electron: Visual Studio Code, Slack, Discord, Spotify desktop, Atom editor, WhatsApp desktop. One codebase deploys to Windows, macOS, and Linux. Combines Chromium browser with Node.js."},
    {heading: "Game Development", content: "JavaScript powers browser-based games using HTML5 Canvas API for 2D graphics, WebGL for 3D graphics, and game engines like Phaser, Three.js, and Babylon.js. Games run directly in browsers without plugins. Multiplayer games use WebSockets for real-time communication. Mobile game frameworks use JavaScript."},
    {heading: "Internet of Things", content: "JavaScript runs on IoT devices using platforms like Johnny-Five (robotics), Espruino (embedded devices), and Node-RED (visual programming). Can control hardware like Arduino, Raspberry Pi, and sensors. Builds automation systems, smart home applications, and industrial control systems."}
  ],
  "How to Add JavaScript": [
    {heading: "Inline JavaScript", content: "JavaScript code written directly in HTML element attributes. Uses event attributes like onclick, onload, onmouseover, onchange, etc. This method mixes HTML and JavaScript, violating separation of concerns. Generally discouraged except for quick tests. Cannot access some JavaScript features like modules.", syntax: "<button onclick=\"alert('Hello!')\">Click Me</button>\n<a href=\"#\" onclick=\"console.log('Clicked'); return false;\">Link</a>", explanation: "Code executes when event occurs. Simple but hard to maintain. Avoid in production code."},
    {heading: "Embedded JavaScript", content: "JavaScript code placed inside <script> tags within HTML document. Scripts in <head> run before page loads. Scripts at end of <body> run after HTML is parsed. Can include multiple script tags. Useful for page-specific code.", syntax: "<head>\n  <script>\n    console.log('In head');\n  </script>\n</head>\n<body>\n  <h1>Hello</h1>\n  <script>\n    console.log('After H1 loaded');\n  </script>\n</body>", explanation: "Scripts block HTML parsing unless async/defer used. Place scripts at end of body for better performance."},
    {heading: "External JavaScript", content: "JavaScript in separate .js files linked via <script src='...'> tag. Recommended approach for production. Benefits: code reusability, browser caching, better organization, separation of concerns. One file can be used across multiple pages.", syntax: "<!-- In HTML -->\n<script src=\"app.js\"></script>\n\n/* In app.js */\nconsole.log('Hello');\nfunction greet(name) {\n  alert('Hello, ' + name);\n}", explanation: "External files are cached by browsers. Better for large codebases. Supports module systems."},
    {heading: "Script Attributes", content: "The defer attribute loads scripts in parallel with HTML parsing but executes them in order after DOM is ready. The async attribute loads and executes scripts asynchronously, potentially before DOM is ready. Choose based on whether script needs DOM access and execution order matters.", syntax: "<!-- Regular: Blocks parsing -->\n<script src=\"app.js\"></script>\n\n<!-- Defer: Executes after DOM ready -->\n<script src=\"app.js\" defer></script>\n\n<!-- Async: Executes whenever ready -->\n<script src=\"analytics.js\" async></script>", explanation: "Defer maintains script order. Async doesn't. Use defer for scripts that need DOM. Use async for independent scripts."},
    {heading: "ES6 Modules", content: "Modern JavaScript supports modules with import/export syntax. Use type='module' attribute. Modules have their own scope (not global), automatically use strict mode, defer by default, and support importing from other modules or packages.", syntax: "<script type=\"module\" src=\"app.js\"></script>\n\n/* In app.js */\nimport { greet } from './utils.js';\nexport function main() {\n  greet('World');\n}", explanation: "Modules provide better code organization. Each module has its own scope. Import/export makes dependencies explicit."}
  ],
  "JavaScript Comments": [
    {heading: "Single-Line Comments", content: "Single-line comments start with // and continue to end of line. Everything after // is ignored. Commonly used for brief explanations, disabling code temporarily, inline documentation, and quick notes.", syntax: "// This is a comment\nlet x = 5; // Set x to 5\n\n// Disabled code:\n// console.log('Not executed');", explanation: "Quick and easy. Most common comment type. Use for short explanations."},
    {heading: "Multi-Line Comments", content: "Multi-line comments start with /* and end with */. Can span multiple lines. Used for longer explanations, function documentation, and commenting out code blocks.", syntax: "/* This comment\n   spans multiple\n   lines */\n\n/* Disabled block:\nfunction old() {\n  return 'Not used';\n}\n*/", explanation: "Useful for longer explanations and disabling multiple lines. Cannot nest multi-line comments."},
    {heading: "JSDoc Comments", content: "Special comment format for documentation. Starts with /** and includes @tags for parameters, return types, examples. IDEs and tools parse JSDoc for autocomplete and documentation generation.", syntax: "/**\n * Adds two numbers\n * @param {number} a - First number\n * @param {number} b - Second number\n * @returns {number} Sum\n */\nfunction add(a, b) {\n  return a + b;\n}", explanation: "Structured documentation format. Enables better IDE support. Generates documentation automatically."}
  ],
  "JavaScript Variables": [
    {heading: "let Declaration", content: "let declares block-scoped variables. Can be reassigned but not redeclared in same scope. Introduced in ES6. Preferred over var for variables that change. Block-scoped means limited to { } where declared.", syntax: "let age = 25;\nage = 26; // OK\n\nif (true) {\n  let message = 'Hello';\n}\n// message not accessible here", explanation: "Use let for variables that need to change. Block scope prevents accidental reuse of variable names."},
    {heading: "const Declaration", content: "const declares block-scoped constants. Cannot be reassigned. Must be initialized when declared. However, object/array properties can be modified. Use const by default unless reassignment is needed.", syntax: "const PI = 3.14159;\n// PI = 3; // Error\n\nconst person = {name: 'John'};\nperson.name = 'Jane'; // OK\nperson.age = 30; // OK", explanation: "const prevents reassignment, not mutation. Objects/arrays declared with const can have their contents modified."},
    {heading: "var Declaration (Legacy)", content: "var is the old way to declare variables. Function-scoped not block-scoped. Can be redeclared. Hoisted to top of scope. Modern code should use let/const instead. Understanding var helps maintain legacy code.", syntax: "var count = 10;\nvar count = 20; // OK but bad\n\nif (true) {\n  var message = 'Hello';\n}\nconsole.log(message); // Works (shouldn't)", explanation: "var has confusing scoping. Avoid in new code. Use let/const for predictable behavior."},
    {heading: "Variable Naming Rules", content: "Names must start with letter, underscore, or dollar sign. Subsequent characters can include digits. Case-sensitive. Cannot be reserved keywords (if, for, function, etc.). Use camelCase convention. Choose descriptive names.", syntax: "// Valid\nlet firstName = 'John';\nlet _private = 42;\nlet $element = document.body;\nlet user123 = 'active';\n\n// Invalid\n// let 123user; // Starts with number\n// let user-name; // Contains hyphen\n// let class; // Reserved word", explanation: "Follow naming rules and conventions. Descriptive names make code self-documenting."},
    {heading: "Local vs Global Variables", content: "Local variables declared inside functions/blocks are only accessible within that scope. Global variables declared outside any function are accessible everywhere. Minimize globals to avoid conflicts.", syntax: "let globalVar = 'global';\n\nfunction test() {\n  let localVar = 'local';\n  console.log(globalVar); // OK\n  console.log(localVar); // OK\n}\n\nconsole.log(globalVar); // OK\n// console.log(localVar); // Error", explanation: "Local scope prevents naming conflicts. Global variables can cause bugs. Prefer local scope."}
  ]
};
