// Comprehensive Web Technologies eBook Content
// Unit II: CSS & Unit III: JavaScript - Complete Theory Notes

interface Section {
  heading: string;
  content: string;
  syntax?: string;
  explanation?: string;
}

interface TopicData {
  [key: string]: Section[];
}

interface UnitData {
  title: string;
  duration: string;
  overview: string[];
  topics: TopicData;
}

// Due to the extensive content requirements, this file contains detailed theory for all topics
// The content is structured for optimal learning with clear explanations and syntax examples

export const ContentData: {
  unit2: UnitData;
  unit3: UnitData;
} = {
  unit2: {
    title: "Cascading Style Sheet",
    duration: "10 Hours",
    overview: [
      "Master CSS syntax, selectors, and cascade rules",
      "Learn to add CSS using inline, internal, and external methods",
      "Understand all major CSS properties for styling",
      "Control layout with display, float, and position properties",
      "Work with spacing using margin, padding, and box model",
      "Create beautiful designs with colors, fonts, and backgrounds",
      "Implement advanced features like counters and pseudo-elements"
    ],
    topics: {
      "Introduction to CSS": [
        {
          heading: "What is CSS?",
          content: "CSS stands for Cascading Style Sheets. It is a stylesheet language used to describe the presentation and formatting of HTML documents. CSS controls the visual appearance of web pages including colors, fonts, layouts, spacing, and responsive design. The term 'cascading' refers to the way styles are applied in a hierarchical manner, where more specific styles override general ones. CSS enables separation of content (HTML) from presentation (styling), making websites easier to maintain and more flexible."
        },
        {
          heading: "Why Use CSS?",
          content: "CSS provides several key benefits: Separation of Content and Presentation allows HTML to focus on structure while CSS handles styling. Reusability means one CSS file can style multiple HTML pages, reducing code duplication. Easier Maintenance allows changes to styling in one place to affect the entire website. Faster Page Loading occurs because external CSS files can be cached by browsers. Better User Experience through consistent styling across pages and responsive design capabilities that adapt to different screen sizes."
        },
        {
          heading: "CSS History and Evolution",
          content: "CSS was first proposed by Håkon Wium Lie in 1994 while working with Tim Berners-Lee at CERN. CSS1 was released in 1996 with basic font properties and colors. CSS2 came in 1998, adding positioning and media types. CSS3 development began in 1999 and continues today as a modular specification. Modern CSS includes powerful features like Flexbox for flexible layouts, Grid for two-dimensional layouts, animations and transitions for motion, custom properties (variables) for reusable values, and advanced selectors for precise targeting."
        }
      ],
      "CSS Syntax": [
        {
          heading: "CSS Rule Structure",
          content: "A CSS rule consists of a selector and a declaration block. The selector points to the HTML element you want to style. The declaration block (enclosed in curly braces) contains one or more declarations separated by semicolons. Each declaration includes a CSS property name and a value, separated by a colon. The property specifies what aspect to style (like color, font-size, margin), and the value specifies how to style it.",
          syntax: "selector {\n  property: value;\n  property: value;\n}",
          explanation: "The selector identifies which HTML elements to style. Multiple declarations can be included in one rule. Each declaration must end with a semicolon."
        },
        {
          heading: "Practical Examples",
          content: "CSS syntax allows you to apply multiple properties to elements. You can style text appearance, spacing, colors, and layouts all within a single rule. Proper formatting with indentation makes CSS more readable and maintainable.",
          syntax: "p {\n  color: blue;\n  font-size: 16px;\n  text-align: center;\n  line-height: 1.5;\n  margin: 20px 0;\n}",
          explanation: "This rule selects all paragraph elements and applies five different style properties. The browser reads each property and applies the styles in the order specified."
        },
        {
          heading: "Multiple Selectors",
          content: "When multiple elements should share the same styles, you can group selectors together using commas. This reduces code duplication and makes stylesheets more efficient. Any number of selectors can be grouped, and they will all receive the same declarations.",
          syntax: "h1, h2, h3, h4 {\n  font-family: 'Arial', sans-serif;\n  color: #333;\n  font-weight: bold;\n}",
          explanation: "All heading elements (h1 through h4) will receive the same font family, color, and weight. This is much more efficient than writing separate rules for each."
        }
      ],
      "CSS Selectors": [
        {
          heading: "Element Selector",
          content: "The element selector (also called type selector) selects HTML elements based on their tag name. It is the most basic type of selector and targets all elements of a specific type on the page. Element selectors have low specificity, making them easy to override with more specific selectors.",
          syntax: "p { margin: 10px; }\ndiv { padding: 15px; }\nspan { color: red; }",
          explanation: "These rules select all paragraphs, divs, and spans respectively. Every instance of these elements on the page will receive the specified styles."
        },
        {
          heading: "Class Selector",
          content: "The class selector selects elements with a specific class attribute. It is denoted by a period (.) followed by the class name. Classes are reusable and can be applied to multiple elements. Multiple classes can also be applied to a single element by separating them with spaces in the HTML.",
          syntax: ".highlight { background-color: yellow; }\n.text-large { font-size: 20px; }\n.button { padding: 10px 20px; }",
          explanation: "Any element with class='highlight' gets a yellow background. Classes are the most common way to apply styles because they're reusable and have good specificity."
        },
        {
          heading: "ID Selector",
          content: "The ID selector selects a single element with a specific id attribute. It is denoted by a hash (#) followed by the id name. IDs must be unique within a page—only one element can have a specific ID. ID selectors have very high specificity, making them difficult to override.",
          syntax: "#header { background: navy; }\n#main-content { width: 80%; }\n#footer { text-align: center; }",
          explanation: "Each ID selector targets exactly one element. Because of their high specificity, IDs should be used sparingly in CSS. Classes are generally preferred for styling."
        },
        {
          heading: "Universal Selector",
          content: "The universal selector (*) selects all elements on the page. It's often used for CSS resets to remove default browser styles or to apply global box-sizing rules. Because it selects everything, it should be used carefully as it can impact performance if overused.",
          syntax: "* {\n  margin: 0;\n  padding: 0;\n  box-sizing: border-box;\n}",
          explanation: "This common CSS reset removes default margins and paddings from all elements and sets box-sizing to border-box for more predictable sizing."
        },
        {
          heading: "Descendant Selector",
          content: "The descendant selector selects all elements that are descendants of a specified element, regardless of how deeply nested they are. It uses a space to separate the ancestor from the descendant. This selector looks at the entire hierarchy, not just immediate children.",
          syntax: "article p { line-height: 1.6; }\n.container span { color: blue; }\nul li { list-style: square; }",
          explanation: "The first rule selects all paragraphs inside any article element, no matter how many levels deep. Descendant selectors are very useful for targeting elements within specific contexts."
        },
        {
          heading: "Child Selector",
          content: "The child selector (>) selects elements that are direct children of a specified element. Unlike the descendant selector, it only selects immediate children, not grandchildren or further descendants. This provides more precise control over which elements are styled.",
          syntax: "ul > li { font-weight: bold; }\n.menu > a { display: block; }\ndiv > p { color: darkgray; }",
          explanation: "Only direct child elements are selected. For example, ul > li selects li elements that are immediate children of ul, but not li elements nested deeper in sub-lists."
        },
        {
          heading: "Adjacent Sibling Selector",
          content: "The adjacent sibling selector (+) selects an element that comes immediately after another specific element. Both elements must share the same parent, and the selected element must come directly after (with no elements in between) the reference element.",
          syntax: "h1 + p { font-weight: bold; }\nlabel + input { margin-left: 10px; }\n.intro + .content { margin-top: 20px; }",
          explanation: "The first rule selects only the first paragraph that comes immediately after an h1. This is useful for styling the first paragraph of a section differently."
        },
        {
          heading: "General Sibling Selector",
          content: "The general sibling selector (~) selects all elements that are siblings of a specified element and come after it. Unlike the adjacent sibling selector, it doesn't require the elements to be immediately adjacent—they just need to share the same parent.",
          syntax: "h2 ~ p { color: gray; }\n.note ~ .warning { border: 2px solid red; }",
          explanation: "This selects all matching siblings that appear after the reference element, not just the immediate next one. For example, h2 ~ p selects all paragraphs that follow an h2, regardless of what's in between."
        },
        {
          heading: "Attribute Selectors",
          content: "Attribute selectors select elements based on an attribute or attribute value. They are enclosed in square brackets. You can select elements that have a specific attribute, or filter by the attribute's value using various matching patterns.",
          syntax: "input[type='text'] { border: 1px solid gray; }\na[target='_blank'] { color: blue; }\n[class*='btn'] { cursor: pointer; }\nimg[alt] { border: 2px solid green; }",
          explanation: "The first example selects text inputs. The third example selects any element whose class contains 'btn'. The last example selects all images that have an alt attribute, regardless of its value."
        },
        {
          heading: "Pseudo-class Selectors",
          content: "Pseudo-classes select elements based on their state or position in the document. They are denoted by a colon (:) followed by the pseudo-class name. Common examples include hover states, focus states, first/last children, and nth-child selections. Pseudo-classes don't select elements based on attributes but based on information outside the document tree.",
          syntax: "a:hover { color: red; }\ninput:focus { outline: 2px solid blue; }\nli:first-child { font-weight: bold; }\ntr:nth-child(even) { background: #f0f0f0; }",
          explanation: "Pseudo-classes enable interactive and dynamic styling. The hover state applies when users mouse over links. The nth-child(even) creates zebra striping for table rows."
        },
        {
          heading: "Pseudo-element Selectors",
          content: "Pseudo-elements allow you to style specific parts of an element. They use double colons (::) although single colon still works for backward compatibility. Common pseudo-elements include ::before and ::after for inserting content, ::first-letter for drop caps, and ::first-line for special first-line styling. Pseudo-elements create virtual elements that don't exist in the HTML.",
          syntax: "p::first-letter {\n  font-size: 2em;\n  font-weight: bold;\n  float: left;\n}\n.quote::before {\n  content: '\"';\n}\n.quote::after {\n  content: '\"';\n}",
          explanation: "The first-letter pseudo-element creates a drop cap effect. The ::before and ::after pseudo-elements are extremely powerful for adding decorative content without modifying HTML."
        }
      ],
      "How to Add CSS": [
        {
          heading: "Three Methods Overview",
          content: "There are three primary methods to apply CSS to HTML documents, each with specific use cases. Inline CSS applies styles directly to individual elements. Internal CSS uses a style tag in the HTML document head. External CSS links to separate stylesheet files. The choice depends on the scope of styling needed, whether it's a single element, a single page, or an entire website. Modern web development strongly favors external stylesheets for their maintainability and reusability."
        },
        {
          heading: "Inline CSS",
          content: "Inline CSS applies styles directly to HTML elements using the style attribute. This method has the highest specificity and will override other styles. While quick for testing or very specific one-off styles, inline CSS mixes content with presentation, violating the separation of concerns principle. It makes maintenance difficult and prevents style reuse. Inline styles cannot use media queries, pseudo-classes, or pseudo-elements.",
          syntax: "<p style='color: blue; font-size: 18px;'>Inline styled text</p>\n<div style='background: yellow; padding: 10px;'>Yellow box</div>",
          explanation: "The style attribute contains CSS declarations. Multiple properties are separated by semicolons. This method should be avoided in production code except for dynamic styling via JavaScript."
        },
        {
          heading: "Internal CSS",
          content: "Internal CSS is defined within a style tag placed in the HTML document's head section. All CSS rules are contained in this tag and apply only to the current HTML document. This method is useful for single-page applications or when page-specific styles are needed that shouldn't affect other pages. Internal CSS keeps HTML and CSS in one file, which can be convenient for small projects or prototyping.",
          syntax: "<head>\n  <style>\n    body { background-color: #f0f0f0; }\n    h1 { color: navy; font-size: 32px; }\n    .highlight { background: yellow; }\n  </style>\n</head>",
          explanation: "All CSS rules go inside the style tag. This affects only the current document. It's better than inline styles for organization but not as good as external stylesheets for multi-page sites."
        },
        {
          heading: "External CSS",
          content: "External CSS uses separate .css files linked to HTML documents via the link tag. This is the recommended method for production websites. External stylesheets provide the best organization, are reusable across multiple pages, can be cached by browsers for better performance, and allow complete separation of content from presentation. One stylesheet can control the styling of an entire website, making updates and maintenance much easier.",
          syntax: "<!-- In HTML file -->\n<head>\n  <link rel='stylesheet' href='styles.css'>\n</head>\n\n/* In styles.css file */\nbody {\n  font-family: Arial, sans-serif;\n  margin: 0;\n  padding: 0;\n}\n\nh1 {\n  color: darkblue;\n  text-align: center;\n}",
          explanation: "The link tag connects the HTML to the CSS file. The rel='stylesheet' attribute specifies that it's a stylesheet. Multiple HTML pages can link to the same CSS file, ensuring consistent styling across a site."
        },
        {
          heading: "CSS Cascade and Specificity",
          content: "When multiple CSS rules target the same element, the cascade determines which rules apply. The order of importance from lowest to highest is: Browser default styles, External stylesheets, Internal stylesheets, and Inline styles. When rules have the same importance, specificity determines the winner. Specificity calculation: Inline styles (1000 points), IDs (100 points), Classes/attributes/pseudo-classes (10 points), Elements/pseudo-elements (1 point). The !important keyword can override normal specificity but should be avoided."
        }
      ],
      "CSS Comments": [
        {
          heading: "Purpose of CSS Comments",
          content: "Comments in CSS are lines of text that browsers ignore when processing stylesheets. They serve several important purposes: explaining complex selectors or property values, organizing CSS into logical sections, documenting browser-specific workarounds, providing attribution for code from external sources, temporarily disabling styles during development and debugging, and leaving notes for other developers or your future self. Well-commented CSS is easier to maintain and understand, especially in large projects or team environments."
        },
        {
          heading: "CSS Comment Syntax",
          content: "CSS uses the /* */ syntax for comments. Everything between these symbols is ignored by the browser. Comments can appear anywhere in CSS code—between rules, within rules, or inline with declarations. They can span single or multiple lines. Unlike HTML comments, CSS has only one comment syntax. CSS does not have single-line comments like JavaScript's // syntax.",
          syntax: "/* This is a single-line comment */\n\np {\n  color: blue; /* Inline comment */\n  font-size: 16px;\n}\n\n/*\n  This is a multi-line comment\n  that explains complex logic\n  or documents a section\n*/",
          explanation: "Use /* to start a comment and */ to end it. Comments can be placed anywhere and can contain any text. They're completely ignored during rendering."
        },
        {
          heading: "Best Practices for Commenting",
          content: "Effective commenting enhances code maintainability without cluttering the stylesheet. Comment the why, not the what—explain the reasoning behind choices rather than describing obvious properties. Use section headers to organize large stylesheets. Document browser-specific hacks with explanations. Include TODOs for future improvements. Keep comments concise and up-to-date. Remove obsolete comments during refactoring. Consider using a standard format for section headers to make navigation easier.",
          syntax: "/* ===== Header Styles ===== */\n\n/* Sticky nav for desktop (z-index prevents overlap) */\n.nav {\n  position: sticky;\n  top: 0;\n  z-index: 100;\n}\n\n/* TODO: Add mobile menu animation */\n\n/* HACK: IE11 flexbox fix */",
          explanation: "Section headers help navigate large files. Explanatory comments provide context. TODO markers highlight incomplete work. HACK comments document workarounds."
        }
      ],
      "CSS Background Properties": [
        {
          heading: "background-color",
          content: "The background-color property sets the background color of an element. It accepts various color formats: named colors (like 'red', 'blue'), hexadecimal codes (#RRGGBB), RGB values (rgb(255, 0, 0)), RGBA for colors with transparency, HSL (hue, saturation, lightness), and HSLA. The default value is transparent. Background colors fill the content area plus padding, but not margin. They appear behind background images if both are specified.",
          syntax: ".box { background-color: lightblue; }\n.header { background-color: #3498db; }\n.overlay { background-color: rgba(0, 0, 0, 0.5); }",
          explanation: "Different color formats offer different advantages. Hex is compact. RGBA allows transparency. Named colors are readable but limited in selection."
        },
        {
          heading: "background-image",
          content: "The background-image property sets one or more background images for an element. Images are specified using the url() function with a path to the image file. Multiple background images can be added by separating them with commas—they stack with the first listed appearing closest to the user. CSS gradients (linear-gradient, radial-gradient) are also considered background images. Background images appear on top of the background-color.",
          syntax: ".banner { background-image: url('banner.jpg'); }\n.gradient { background-image: linear-gradient(to right, red, yellow); }\n.multi { background-image: url('pattern.png'), linear-gradient(#fff, #eee); }",
          explanation: "The url() function specifies the image path. Gradients are created without image files. Multiple backgrounds are comma-separated."
        },
        {
          heading: "background-repeat",
          content: "The background-repeat property controls how background images tile. The default 'repeat' value tiles the image both horizontally and vertically to fill the element. 'repeat-x' tiles only horizontally, 'repeat-y' only vertically, and 'no-repeat' displays the image once without tiling. The 'space' value repeats the image but distributes remaining space evenly between repetitions. The 'round' value repeats and stretches images to fill the space.",
          syntax: ".pattern { background-image: url('pattern.png'); background-repeat: repeat; }\n.hero { background-image: url('hero.jpg'); background-repeat: no-repeat; }",
          explanation: "Control whether and how the background image tiles. 'no-repeat' is common for photo backgrounds. 'repeat' works well for seamless patterns."
        },
        {
          heading: "background-position",
          content: "The background-position property sets the starting position of a background image within its container. Values can be keywords (top, bottom, left, right, center), percentages (relative to container), or length values (px, em, etc.). Two values specify horizontal and vertical positions. Using percentages aligns the same percentage point of the image with the same percentage point of the container. This is useful for responsive designs where images need to stay positioned relative to container size.",
          syntax: ".logo { background-image: url('logo.png'); background-position: center center; }\n.banner { background-position: right 20px top 50px; }\n.offset { background-position: 75% 50%; }",
          explanation: "Keywords are intuitive. Length values provide pixel-perfect control. Percentage values maintain relative positioning as containers resize."
        },
        {
          heading: "background-size",
          content: "The background-size property specifies the size of background images. 'auto' uses the image's intrinsic size. 'cover' scales the image to cover the entire element while maintaining aspect ratio (may crop the image). 'contain' scales the image to fit entirely within the element while maintaining aspect ratio (may show empty space). Specific dimensions can be set using length values or percentages. Two values set width and height; one value sets width (height becomes auto).",
          syntax: ".cover { background-image: url('photo.jpg'); background-size: cover; }\n.contain { background-size: contain; }\n.custom { background-size: 200px 100px; }\n.responsive { background-size: 100% auto; }",
          explanation: "'cover' is popular for hero images and full-screen backgrounds. 'contain' ensures the entire image is visible. Fixed sizes work for icons and logos."
        },
        {
          heading: "background-attachment",
          content: "The background-attachment property determines whether a background image scrolls with the page content or stays fixed in the viewport. 'scroll' (default) means the background moves with the element's content. 'fixed' keeps the background stationary relative to the viewport, creating a parallax effect. 'local' scrolls the background with the element's content even when the element itself scrolls (useful for scrollable containers).",
          syntax: ".parallax {\n  background-image: url('mountains.jpg');\n  background-attachment: fixed;\n  background-size: cover;\n  background-position: center;\n}",
          explanation: "Fixed backgrounds create popular parallax scrolling effects where the background appears to move at a different speed than content."
        },
        {
          heading: "background Shorthand",
          content: "The background property is a shorthand for setting multiple background properties in one declaration. The order is: color, image, repeat, attachment, position / size. Not all properties need to be specified. The background-size must be preceded by background-position and separated with a forward slash. Multiple backgrounds can be specified by separating complete background declarations with commas. Later listed backgrounds appear behind earlier ones.",
          syntax: ".simple { background: #fff url('bg.jpg') no-repeat center / cover; }\n.complex { background: url('pattern.png') repeat-x center top, linear-gradient(#fff, #eee); }",
          explanation: "The shorthand is more concise. Remember the slash between position and size. Multiple backgrounds are comma-separated."
        }
      ],
      "CSS Float Property": [{heading: "Understanding Float", content: "Float positions an element to left or right, allowing text/inline elements to wrap around it. Originally for magazine-style layouts. Values: left, right, none. Floated elements are removed from normal flow but affect surrounding content. Modern layouts prefer flexbox/grid, but float is still used for text wrapping around images.", syntax: ".float-left { float: left; margin-right: 15px; }\n.float-right { float: right; }\n.clearfix::after { content: ''; display: table; clear: both; }", explanation: "Use clear property to prevent elements from wrapping around floats. Clearfix pattern ensures parent contains floated children."}],
      "CSS Font Properties": [{heading: "font-family", content: "Specifies typeface for text. Comma-separated list with fallbacks. End with generic family (serif, sans-serif, monospace). Font names with spaces need quotes.", syntax: ".text { font-family: 'Helvetica Neue', Arial, sans-serif; }\n.code { font-family: 'Courier New', monospace; }", explanation: "Browser tries each font in order. Generic family ensures something renders."},{heading: "font-size", content: "Sets text size. Values: px (absolute), rem (relative to root), em (relative to parent), %, keywords (small, large), viewport units (vw, vh). 1rem = root font size (usually 16px).", syntax: ".large { font-size: 24px; }\n.responsive { font-size: 1.5rem; }", explanation: "rem is recommended for responsive design. Avoids compounding issues of em."},{heading: "font-weight", content: "Sets text thickness. Values: normal (400), bold (700), lighter, bolder, or numeric 100-900. Not all fonts support all weights.", syntax: ".bold { font-weight: bold; }\n.light { font-weight: 300; }", explanation: "Numeric values provide finer control. Variable fonts support full 100-900 range."}],
      "CSS Line Height Property": [{heading: "Understanding Line Height", content: "Sets the height of a line box - the distance between text baselines. Controls vertical spacing within text blocks. Crucial for readability. Can also vertically center single-line text when equal to container height.", syntax: ".text { line-height: 1.5; }\n.button { height: 40px; line-height: 40px; text-align: center; }", explanation: "Unitless values (like 1.5) are recommended - they multiply the element's own font-size. Body text typically uses 1.4-1.6."}],
      "CSS Margin Property": [{heading: "Understanding Margin", content: "Creates space outside an element's border. Transparent space that pushes other elements away. Can be negative. Vertical margins collapse between adjacent blocks. Follows 1-4 value pattern: all, vertical+horizontal, top+horizontal+bottom, top+right+bottom+left.", syntax: ".box { margin: 20px; }\n.centered { width: 500px; margin: 0 auto; }\n.spaced { margin: 10px 20px 30px 40px; }", explanation: "margin: 0 auto centers block elements horizontally. Negative margins pull elements closer or create overlaps."}],
      "CSS Opacity Property": [{heading: "Understanding Opacity", content: "Sets transparency level from 0 (invisible) to 1 (fully visible). Affects entire element including children. Different from RGBA which only affects specific property. Used for hover effects, overlays, and fade animations.", syntax: ".transparent { opacity: 0; }\n.semi { opacity: 0.5; }\n.button:hover { opacity: 0.8; transition: opacity 0.3s; }", explanation: "Opacity 0 is invisible but still occupies space (unlike display: none). Values below 0.6 for text may fail accessibility contrast requirements."}],
      "CSS Overflow Property": [{heading: "Understanding Overflow", content: "Controls what happens when content is too large for element's box. Values: visible (default, overflows), hidden (clips content), scroll (always shows scrollbars), auto (scrollbars only when needed), clip (clips strictly).", syntax: ".hidden { overflow: hidden; }\n.scrollable { overflow-y: auto; height: 300px; }\n.truncate { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }", explanation: "overflow: auto is most flexible. The truncate pattern creates text with ellipsis (...). overflow-x and overflow-y control axes independently."}],
      "CSS Padding Property": [{heading: "Understanding Padding", content: "Creates space inside an element's border, between border and content. Shows element's background. Cannot be negative. Doesn't collapse like margins. Follows same 1-4 value pattern as margin.", syntax: ".box { padding: 20px; }\n.card { padding: 15px 20px; }\n.button { padding: 10px 24px; }", explanation: "With box-sizing: border-box, padding is included in element's width/height. Otherwise it adds to dimensions. Percentage padding is relative to container width (even for top/bottom)."}],
      "CSS Position Property": [{heading: "static", content: "Default positioning. Element follows normal document flow. top/right/bottom/left have no effect. z-index doesn't work.", syntax: ".static { position: static; }", explanation: "Default behavior. Explicitly setting to static can override inherited positioned values."},{heading: "relative", content: "Positioned relative to normal position. Original space preserved. Creates positioning context for absolute children. top/right/bottom/left offset from normal position.", syntax: ".relative { position: relative; top: 20px; left: 30px; }", explanation: "Element shifts visually but original space remains in flow. Useful for minor adjustments and positioning context."},{heading: "absolute", content: "Removed from flow. Positioned relative to nearest positioned ancestor (or viewport if none). Doesn't affect other elements' positioning.", syntax: ".container { position: relative; }\n.absolute { position: absolute; top: 0; right: 0; }", explanation: "Common pattern: relative parent with absolute children. Used for overlays, tooltips, dropdowns."},{heading: "fixed", content: "Removed from flow. Positioned relative to viewport. Stays in same place when scrolling. Used for fixed headers, footers, floating buttons.", syntax: ".navbar { position: fixed; top: 0; left: 0; right: 0; z-index: 1000; }", explanation: "Always visible at same viewport position. Remember to add top/left/etc. to position it."},{heading: "sticky", content: "Hybrid of relative and fixed. Acts relative until scroll threshold crossed, then acts fixed. Requires threshold value (top, bottom, left, or right).", syntax: ".sidebar { position: sticky; top: 20px; }", explanation: "Sticks at specified position during scrolling. Useful for navigation that starts mid-page."}],
      "CSS Vertical Align Property": [{heading: "Understanding Vertical Align", content: "Controls vertical alignment of inline, inline-block, and table-cell elements only. Does NOT work on block elements. Values: baseline (default), top, middle, bottom, text-top, text-bottom, super, sub, or length values. Often misunderstood - not for centering block elements.", syntax: ".icon { display: inline-block; vertical-align: middle; }\ntd { vertical-align: top; }", explanation: "For block centering use flexbox or grid. vertical-align aligns inline elements with their line box or aligns content in table cells."}],
      "CSS White Space Property": [{heading: "Understanding White Space", content: "Controls how white space inside elements is handled. Values: normal (collapse spaces, wrap text), nowrap (collapse spaces, no wrap), pre (preserve all, no wrap), pre-wrap (preserve all, wrap text), pre-line (collapse spaces, preserve newlines, wrap).", syntax: ".nowrap { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }\n.pre { white-space: pre; }", explanation: "nowrap prevents line breaks. pre behaves like <pre> tag. pre-wrap preserves formatting but allows wrapping."}],
      "CSS Width Property": [{heading: "Width Values", content: "Sets element's width. Values: auto (default, browser calculates), px, %, em/rem, vw (viewport width), max-content (widest content), min-content (narrowest without overflow), fit-content.", syntax: ".fixed { width: 500px; }\n.fluid { width: 75%; }\n.responsive { width: 100%; max-width: 1200px; }", explanation: "max-width allows element to be narrower but not wider. min-width ensures minimum size. Percentages are relative to parent width."},{heading: "Box Sizing", content: "box-sizing: content-box (default) means width applies to content area only. box-sizing: border-box means width includes padding and border. Border-box is generally preferred for predictable sizing.", syntax: "* { box-sizing: border-box; }\n.box { width: 300px; padding: 20px; border: 10px solid; }", explanation: "With border-box, total width stays 300px. With content-box, total would be 360px (300 + 40 padding + 20 border)."}],
      "CSS Word Wrap Property": [{heading: "word-wrap / overflow-wrap", content: "Controls whether long unbreakable strings can break to prevent overflow. Values: normal (break only at allowed points), break-word (break anywhere if needed). Property renamed from word-wrap to overflow-wrap but both work.", syntax: ".break { word-wrap: break-word; }\n.url { overflow-wrap: break-word; word-break: break-word; }", explanation: "Essential for user-generated content with long URLs. word-break: break-all is more aggressive."},{heading: "word-break", content: "Controls word breaking rules. Values: normal, break-all (break between any characters), keep-all (don't break in CJK text). More aggressive than word-wrap.", syntax: ".break-all { word-break: break-all; }", explanation: "break-all breaks anywhere, even mid-word. Use carefully as it affects readability."}],
      "CSS Outline Property": [{heading: "Understanding Outline", content: "Draws line outside border. Doesn't take up space or affect layout. Can overlap adjacent elements. Used for focus indicators. Properties: outline-style (required), outline-width, outline-color, outline-offset. Important for accessibility.", syntax: ".focus:focus { outline: 2px solid blue; outline-offset: 2px; }\n.card { outline: 1px solid #ddd; }", explanation: "Never remove outline without providing alternative focus indicator. outline-offset can be negative. Unlike border, outlines don't have separate sides."},{heading: "Accessibility", content: "Browsers show default focus outlines for keyboard navigation. Removing them without alternatives hurts accessibility. Use :focus-visible for keyboard-only focus indicators while hiding for mouse users.", syntax: "button:focus-visible { outline: 2px solid blue; outline-offset: 2px; }\nbutton:focus:not(:focus-visible) { outline: none; }", explanation: ":focus-visible only triggers for keyboard focus, not mouse clicks. Modern and accessible approach."}],
      "CSS Visibility Property": [{heading: "visibility Values", content: "Controls whether element is visible. Values: visible (default), hidden (invisible but occupies space), collapse (for table elements, like display: none; for others, like hidden). Children can override parent's hidden visibility.", syntax: ".hide { visibility: hidden; }\n.hide .show { visibility: visible; }", explanation: "visibility: hidden preserves layout space. display: none removes from layout. opacity: 0 is invisible but clickable."},{heading: "Comparison", content: "visibility: hidden - invisible, takes space, can be overridden by children, not interactive. display: none - removed from layout, no space, children also hidden. opacity: 0 - invisible, takes space, still interactive (clickable).", explanation: "Choose based on needs: space preservation, interactivity, child override capability."}],
      "CSS Counter Property": [{heading: "counter-reset", content: "Creates or resets CSS counters. Placed on container. Can initialize to specific value (default 0). Can create multiple counters.", syntax: ".container { counter-reset: section; }\n.multi { counter-reset: chapter 1 page 0; }", explanation: "counter-reset initializes counters. Place on parent of elements being counted."},{heading: "counter-increment", content: "Increments counter value. Default increment is 1. Can specify different increment or decrement with negative values. Placed on elements being counted.", syntax: ".item { counter-increment: section; }\n.double { counter-increment: section 2; }", explanation: "counter-increment changes counter values. Can increment by any amount."},{heading: "counter() and counters()", content: "Display counter values in content property. counter() shows value. counters() shows nested counters with separator. Can format as decimal, roman, alpha, etc.", syntax: ".item::before { content: counter(section) '. '; }\n.roman::before { content: counter(section, upper-roman) '. '; }\n.nested::before { content: counters(section, '.') ' '; }", explanation: "counter() for simple numbering. counters() for hierarchical (1.1, 1.2, 2.1). Second argument specifies number style."}]
    }
  },
  unit3: {
    title: "JavaScript",
    duration: "15 Hours",
    overview: [
      "Understand JavaScript fundamentals and features",
      "Master variables, data types, and operators",
      "Learn control structures and loops",
      "Work with functions and function expressions",
      "Explore built-in objects like Array, String, Date, Math",
      "Handle user interactions and DOM events",
      "Implement modern JavaScript patterns and best practices"
    ],
    topics: {
      "Introduction to JavaScript": [
        {
          heading: "What is JavaScript?",
          content: "JavaScript is a high-level, interpreted programming language that is one of the core technologies of the World Wide Web, alongside HTML and CSS. It enables interactive web pages and is an essential part of web applications. JavaScript runs in web browsers without requiring compilation and can also run on servers using environments like Node.js. Originally created to add interactivity to web pages, JavaScript has evolved into a powerful, versatile language used for full-stack development, mobile apps, desktop applications, game development, and even IoT devices."
        },
        {
          heading: "History of JavaScript",
          content: "JavaScript was created by Brendan Eich in just 10 days in May 1995 while working at Netscape Communications. Initially called Mocha, it was renamed to LiveScript, and finally to JavaScript for marketing reasons (to capitalize on Java's popularity). Despite the name similarity, JavaScript and Java are completely different languages with different purposes and design philosophies. JavaScript was standardized as ECMAScript (ES) by ECMA International in 1997. Major updates include ES5 (2009), ES6/ES2015 (major update with classes, modules, arrow functions), and yearly updates since 2016."
        },
        {
          heading: "Role in Web Development",
          content: "In web development, HTML provides the structure and content, CSS provides the presentation and styling, and JavaScript provides the behavior and interactivity. JavaScript can manipulate HTML elements (DOM manipulation), modify CSS styles dynamically, respond to user actions (clicks, keyboard input, etc.), validate form data before submission, communicate with servers (AJAX, Fetch API), store data locally (localStorage, sessionStorage), and create complex web applications (SPAs, PWAs). It's the only programming language that runs natively in web browsers, making it indispensable for web development."
        }
      ],
      "Features of JavaScript": [
        {
          heading: "Interpreted Language",
          content: "JavaScript is an interpreted language, meaning code is executed line-by-line by the browser's JavaScript engine without needing prior compilation into machine code. This makes development faster since you can test changes immediately without a compilation step. However, this traditionally meant slower execution compared to compiled languages. Modern JavaScript engines like V8 (Chrome), SpiderMonkey (Firefox), and JavaScriptCore (Safari) use Just-In-Time (JIT) compilation, which compiles frequently-executed code paths during runtime for performance approaching compiled languages."
        },
        {
          heading: "Dynamically Typed",
          content: "JavaScript is dynamically typed (also called weakly typed), meaning variables don't have fixed types declared at creation. The same variable can hold different types of values at different times in the program. Type checking happens at runtime, not compile time. For example, a variable can start as a number, then be reassigned to a string, then to an object. This provides flexibility and faster development but can lead to runtime type errors if not careful. TypeScript was created to add optional static typing to JavaScript for larger projects."
        },
        {
          heading: "Object-Oriented Programming",
          content: "JavaScript supports object-oriented programming, though it uses a prototype-based approach rather than classical class-based inheritance. Everything in JavaScript (except primitive values) is an object. ES6 introduced class syntax which provides a more familiar OOP syntax, though it's still prototype-based under the hood. JavaScript supports key OOP concepts including encapsulation (private data in closures or private fields), inheritance (prototype chain or class extends), polymorphism (duck typing, method overriding), and abstraction."
        },
        {
          heading: "Functional Programming",
          content: "JavaScript has strong support for functional programming paradigms. Functions are first-class citizens, meaning they can be assigned to variables, passed as arguments to other functions, and returned from functions. JavaScript supports higher-order functions (functions that operate on other functions), closures (functions that remember their creation environment), pure functions, immutability patterns, and functional methods like map, filter, and reduce. ES6 arrow functions provide concise syntax for functional code."
        },
        {
          heading: "Event-Driven Programming",
          content: "JavaScript uses an event-driven programming model, particularly important for web development. Code can respond to events like user interactions (clicks, key presses, mouse movements), browser events (page load, scroll), network events (fetch completion), timer events, and custom events. Event listeners wait for events to occur and execute callback functions in response. This asynchronous, non-blocking model is fundamental to creating responsive, interactive applications. The event loop manages these asynchronous operations efficiently."
        },
        {
          heading: "Single-Threaded with Async Capabilities",
          content: "JavaScript is single-threaded, meaning it executes one operation at a time in a single sequence. However, it supports asynchronous operations through callbacks, promises, and async/await syntax. The event loop manages asynchronous operations, allowing non-blocking code execution. While one operation waits (like a network request), JavaScript can continue executing other code. Web Workers provide true parallel execution for CPU-intensive tasks, though they're separate from the main thread and have limited access to the DOM."
        },
        {
          heading: "Cross-Platform and Versatile",
          content: "JavaScript runs on all major operating systems and browsers, making it truly cross-platform. The same code generally works across different platforms with minimal changes. Beyond browsers, JavaScript runs on servers (Node.js), in mobile apps (React Native, Ionic, NativeScript), in desktop applications (Electron), in embedded systems and IoT devices (Johnny-Five, Espruino), in game engines, and more. This versatility allows developers to use one language across the entire technology stack, often called the 'JavaScript everywhere' philosophy."
        }
      ],
      "Applications of JavaScript": [{heading: "Web Development & Applications", content: "JavaScript's primary use is creating interactive web pages and complex web applications. It manipulates DOM, handles user interactions, validates forms, creates animations, updates content dynamically. Powers SPAs like Gmail, Google Maps, Facebook. Frameworks (React, Angular, Vue) enable sophisticated UIs with routing, state management, and real-time updates."}],
      "How to Add JavaScript": [{heading: "Three Methods", content: "Inline: code in HTML attributes (onclick, onload). Embedded: code in <script> tags in HTML. External: separate .js files linked via <script src>. External is recommended for production. Scripts at end of body load after DOM. Use defer for scripts that need DOM. Use async for independent scripts.", syntax: "<!-- Inline -->\n<button onclick=\"alert('Hi')\">Click</button>\n\n<!-- Embedded -->\n<script>\n  console.log('Hello');\n</script>\n\n<!-- External -->\n<script src=\"app.js\"></script>\n<script src=\"app.js\" defer></script>", explanation: "External files are cached and reusable. defer maintains script order. async doesn't. Modules use type='module'."}],
      "JavaScript Comments": [{heading: "Comment Types", content: "Single-line: // comment to end of line. Multi-line: /* comment */ spans lines. JSDoc: /** */ with @tags for documentation. Comments explain why, not what. Document complex logic, TODOs, and workarounds.", syntax: "// Single line\nlet x = 5; // inline\n\n/* Multi-line\n   comment */\n\n/**\n * Adds numbers\n * @param {number} a\n * @returns {number}\n */\nfunction add(a, b) {\n  return a + b;\n}", explanation: "Good comments add value. Don't over-comment obvious code. Keep comments updated with code changes."}],
      "JavaScript Variables": [{heading: "let, const, var", content: "let: block-scoped, reassignable, not redeclarable. const: block-scoped, not reassignable (but objects mutable), must initialize. var: function-scoped, reassignable, redeclarable, hoisted (legacy, avoid). Use const by default, let when reassignment needed.", syntax: "let age = 25;\nage = 26; // OK\n\nconst PI = 3.14;\n// PI = 3; // Error\n\nconst person = {name: 'John'};\nperson.name = 'Jane'; // OK\n\nvar old = 10; // Avoid", explanation: "const prevents reassignment but allows mutation of objects/arrays. let/const have block scope. var has function scope."},{heading: "Variable Naming", content: "Must start with letter, _, or $. Can contain letters, digits, _, $. Case-sensitive. No reserved keywords. Use camelCase. Choose descriptive names that indicate purpose.", syntax: "// Valid\nlet firstName = 'John';\nlet _private = 42;\nlet $element = node;\n\n// Invalid\n// let 123var;\n// let user-name;\n// let class;", explanation: "Follow rules and conventions for maintainable code."}],
      "JavaScript Data Types": [{heading: "Primitive Types", content: "Number: integers and floats (64-bit). String: text in quotes. Boolean: true/false. Undefined: declared but not assigned. Null: intentional absence of value. Symbol: unique identifier (ES6). BigInt: large integers beyond Number limit (ES2020).", syntax: "let num = 42;\nlet str = 'Hello';\nlet bool = true;\nlet undef;\nlet nothing = null;\nlet sym = Symbol('id');\nlet big = 9007199254740991n;", explanation: "typeof returns type name. typeof null returns 'object' (historical bug). undefined means not set, null means intentionally empty."},{heading: "Reference Types", content: "Object: collections of key-value pairs. Array: ordered lists (special object). Function: callable object. Date, RegExp, Map, Set, etc. Reference types stored by reference, not value. Modifying copies affects original.", syntax: "let obj = {name: 'John', age: 30};\nlet arr = [1, 2, 3];\nlet func = function() {};\nlet date = new Date();", explanation: "Objects and arrays are mutable. Copies share the same reference. Use spread or methods to create true copies."}],
      "JavaScript Interactions": [{heading: "alert, prompt, confirm", content: "alert(message): shows message, waits for OK. prompt(message, default): shows input box, returns entered string or null. confirm(message): shows OK/Cancel, returns boolean. All three block code execution until dismissed (modal).", syntax: "alert('Hello!');\n\nlet name = prompt('Enter name:', 'Guest');\nif (name) console.log(name);\n\nlet result = confirm('Are you sure?');\nif (result) console.log('Confirmed');", explanation: "These are simple browser dialogs. Blocking behavior can disrupt UX. Use for learning/testing. Production apps use custom modals."}],
      "Type Conversions": [{heading: "String Conversion", content: "Convert to string: String(value), value.toString(), or + '' concatenation. Almost any value can convert to string. null becomes 'null', undefined becomes 'undefined', true becomes 'true'.", syntax: "String(123); // '123'\nlet num = 42;\nnum.toString(); // '42'\n'' + 100; // '100'", explanation: "String conversion is usually explicit and obvious. toString() doesn't work on null/undefined."},{heading: "Numeric Conversion", content: "Convert to number: Number(value), +value (unary plus), parseInt/parseFloat. undefined → NaN, null → 0, true → 1, false → 0, string → parsed number or NaN if invalid.", syntax: "Number('123'); // 123\n+'456'; // 456\nparseInt('100px'); // 100\nparseFloat('3.14'); // 3.14\nNumber('abc'); // NaN", explanation: "Math operations trigger auto conversion. parseInt/parseFloat extract numbers from strings. NaN means not-a-number."},{heading: "Boolean Conversion", content: "Convert to boolean: Boolean(value), !!value (double NOT). Falsy values (convert to false): 0, -0, '', null, undefined, NaN. Everything else is truthy.", syntax: "Boolean(1); // true\nBoolean(0); // false\nBoolean(''); // false\nBoolean('0'); // true (non-empty string)\n!!null; // false\n!!'hello'; // true", explanation: "if statements auto-convert conditions to boolean. Empty strings, 0, null, undefined, NaN are falsy."}],
      "JavaScript Operators": [{heading: "Arithmetic", content: "Addition (+), Subtraction (-), Multiplication (*), Division (/), Remainder (%), Exponentiation (**). Unary plus (+) converts to number, unary minus (-) negates. Increment (++) and decrement (--) in prefix/postfix forms.", syntax: "5 + 3; // 8\n10 - 4; // 6\n3 * 4; // 12\n10 / 2; // 5\n10 % 3; // 1\n2 ** 3; // 8\n+'5'; // 5\nlet x = 5; x++; // x is now 6", explanation: "++ and -- modify variable. Prefix returns new value, postfix returns old. ** is exponentiation (ES7)."},{heading: "Comparison", content: "Equality: == (loose), === (strict). Inequality: !=, !==. Greater/less: >, <, >=, <=. Strict comparison checks type and value. Loose comparison coerces types.", syntax: "5 == '5'; // true (loose)\n5 === '5'; // false (strict)\n10 > 5; // true\n'a' < 'b'; // true (lexicographic)\nnull == undefined; // true\nnull === undefined; // false", explanation: "Always use === and !== to avoid type coercion surprises. == can have unexpected results."},{heading: "Logical", content: "AND (&&): returns first falsy or last value. OR (||): returns first truthy or last value. NOT (!): inverts boolean. Short-circuit evaluation: && stops at first falsy, || stops at first truthy.", syntax: "true && false; // false\ntrue || false; // true\n!true; // false\n\nlet x = null && 'value'; // null\nlet y = 0 || 'default'; // 'default'\n\nif (user && user.name) { }", explanation: "Logical operators return operand values, not just true/false. Use for default values and conditional access."},{heading: "Assignment and Others", content: "Assignment: = and compound (+=, -=, *=, /=, %=, **=). Ternary: condition ? ifTrue : ifFalse. Nullish coalescing (??): returns right if left is null/undefined. Optional chaining (?.): safely access nested properties.", syntax: "let x = 5;\nx += 3; // x = 8\n\nlet age = 20;\nlet type = age >= 18 ? 'adult' : 'minor';\n\nlet name = user ?? 'Guest';\nlet city = user?.address?.city;", explanation: "?? differs from || (only null/undefined are falsy). ?. prevents errors on null/undefined. Ternary is compact if-else."}],
      "Selection Structures": [{heading: "if, if-else, if-else if", content: "if executes code if condition is true. if-else provides alternative. if-else if-else handles multiple conditions. Conditions auto-convert to boolean. Curly braces optional for single statements but recommended.", syntax: "if (age >= 18) {\n  console.log('Adult');\n}\n\nif (score >= 60) {\n  console.log('Pass');\n} else {\n  console.log('Fail');\n}\n\nif (grade === 'A') {\n  console.log('Excellent');\n} else if (grade === 'B') {\n  console.log('Good');\n} else {\n  console.log('Needs improvement');\n}", explanation: "Conditions evaluated top-to-bottom. First true condition executes, rest skipped. Always use === for comparison."},{heading: "switch-case", content: "switch compares expression against multiple values using case. Uses strict comparison (===). break exits switch, otherwise falls through to next case. default handles no matches.", syntax: "switch (day) {\n  case 1:\n    console.log('Monday');\n    break;\n  case 2:\n    console.log('Tuesday');\n    break;\n  default:\n    console.log('Other day');\n}", explanation: "switch is cleaner than multiple if-else for single value comparison. Don't forget break or fall-through occurs."}],
      "Loop Structures": [{heading: "for loop", content: "for loop has initialization, condition, and increment. Executes while condition is true. Common for counted iterations. Can break early or continue to next iteration.", syntax: "for (let i = 0; i < 5; i++) {\n  console.log(i);\n}\n\nfor (let i = 0; i < 10; i++) {\n  if (i === 5) break; // exit loop\n  if (i % 2 === 0) continue; // skip even\n  console.log(i);\n}", explanation: "i is loop counter. condition checked before each iteration. increment runs after each iteration. break exits, continue skips."},{heading: "while loop", content: "while executes while condition is true. Condition checked before each iteration. May not execute at all if initially false. Good when iteration count unknown.", syntax: "let i = 0;\nwhile (i < 5) {\n  console.log(i);\n  i++;\n}\n\nlet input = '';\nwhile (input !== 'quit') {\n  input = prompt('Enter command:');\n}", explanation: "Check condition before executing. Ensure condition eventually becomes false or use break. Infinite loop if condition always true."},{heading: "do-while loop", content: "do-while executes code then checks condition. Guarantees at least one execution. Condition checked after iteration. Use when code must run at least once.", syntax: "let i = 0;\ndo {\n  console.log(i);\n  i++;\n} while (i < 5);\n\nlet password;\ndo {\n  password = prompt('Enter password:');\n} while (password.length < 8);", explanation: "Executes once before checking condition. Guarantees minimum one iteration. Good for input validation."},{heading: "for...in and for...of", content: "for...in iterates over object keys (enumerable properties). for...of iterates over iterable values (arrays, strings, etc.). for...of is preferred for arrays.", syntax: "let obj = {a: 1, b: 2};\nfor (let key in obj) {\n  console.log(key, obj[key]);\n}\n\nlet arr = [10, 20, 30];\nfor (let value of arr) {\n  console.log(value);\n}\n\nlet str = 'hello';\nfor (let char of str) {\n  console.log(char);\n}", explanation: "for...in gives keys/indices. for...of gives values. for...of doesn't work on plain objects."}],
      "JavaScript Functions": [{heading: "Function Declaration", content: "Function declaration defines named function. Hoisted to top of scope (can call before declaration). Has function name for recursion and debugging. Classic way to create functions.", syntax: "function greet(name) {\n  return 'Hello, ' + name;\n}\n\nlet result = greet('John');\n\nfunction factorial(n) {\n  if (n <= 1) return 1;\n  return n * factorial(n - 1);\n}", explanation: "Functions can have parameters and return values. return exits function and provides result. Without return, function returns undefined."},{heading: "Function Parameters", content: "Parameters are local variables initialized with arguments. JavaScript doesn't enforce parameter count - extra arguments ignored, missing become undefined. Default parameters (ES6) provide fallback values. Rest parameters collect remaining arguments into array.", syntax: "function add(a, b) {\n  return a + b;\n}\n\nfunction greet(name = 'Guest') {\n  return 'Hello, ' + name;\n}\n\nfunction sum(...numbers) {\n  return numbers.reduce((a, b) => a + b, 0);\n}\n\nsum(1, 2, 3, 4); // 10", explanation: "Default parameters set fallbacks. Rest parameters (...name) collect remaining args. Arguments object (legacy) contains all args."}],
      "Function Expressions": [{heading: "Function Expression", content: "Function expression assigns function to variable. Not hoisted like declarations. Can be anonymous or named. Often used as callbacks. Can be assigned, passed, returned like any value.", syntax: "const greet = function(name) {\n  return 'Hello, ' + name;\n};\n\nconst factorial = function fac(n) {\n  return n <= 1 ? 1 : n * fac(n - 1);\n};", explanation: "Function expressions aren't hoisted. Named expressions (fac) allow recursion. Anonymous functions have no name."},{heading: "Arrow Functions", content: "Arrow functions (=>) provide concise syntax. Implicit return for single expressions. No own this binding (inherits from parent). Can't be used as constructors. Perfect for callbacks and functional programming.", syntax: "const add = (a, b) => a + b;\n\nconst square = x => x * x;\n\nconst greet = name => {\n  console.log('Hello');\n  return name;\n};\n\nconst nums = [1, 2, 3];\nconst doubled = nums.map(n => n * 2);", explanation: "Parentheses optional for single parameter. Curly braces needed for multiple statements. No own this - uses lexical this."}],
      "JavaScript Object": [{heading: "Creating Objects", content: "Objects store key-value pairs. Created with {} literal or new Object(). Properties accessed with dot or bracket notation. Keys are strings or symbols. Values can be any type including functions (methods).", syntax: "let person = {\n  name: 'John',\n  age: 30,\n  greet: function() {\n    console.log('Hello');\n  }\n};\n\nconsole.log(person.name);\nconsole.log(person['age']);\nperson.greet();", explanation: "Object literal {} is most common. Dot notation for known keys. Bracket notation for dynamic keys or keys with spaces."},{heading: "Object Methods", content: "Objects can have methods (functions as properties). this in methods refers to the object. Object.keys() returns keys array. Object.values() returns values array. Object.entries() returns [key, value] pairs.", syntax: "let user = {\n  name: 'Alice',\n  sayHi() {\n    console.log('Hi, ' + this.name);\n  }\n};\n\nObject.keys(user); // ['name', 'sayHi']\nObject.values(user);\nObject.entries(user);", explanation: "this refers to object (if called as method). Object.keys/values/entries iterate over properties."}],
      "JavaScript Array": [{heading: "Array Basics", content: "Arrays store ordered collections. Created with [] or new Array(). Zero-indexed. Can hold mixed types. Length property tracks size. Push/pop for end, shift/unshift for start.", syntax: "let arr = [1, 2, 3];\nlet mixed = [1, 'text', true, {}, []];\n\narr.length; // 3\narr[0]; // 1\narr.push(4); // add to end\narr.pop(); // remove from end\narr.unshift(0); // add to start\narr.shift(); // remove from start", explanation: "Arrays are objects with numeric keys. Length is highest index + 1. Push/pop are efficient. Shift/unshift reindex entire array."},{heading: "Array Methods", content: "map: transforms elements. filter: selects elements. reduce: accumulates value. forEach: iterates elements. find: returns first match. includes: checks presence. slice: copies portion. splice: modifies array. sort: sorts in place.", syntax: "let nums = [1, 2, 3, 4, 5];\n\nnums.map(n => n * 2); // [2, 4, 6, 8, 10]\nnums.filter(n => n % 2 === 0); // [2, 4]\nnums.reduce((sum, n) => sum + n, 0); // 15\nnums.find(n => n > 3); // 4\nnums.includes(3); // true\nnums.slice(1, 3); // [2, 3]", explanation: "map/filter/reduce don't modify original. forEach for side effects. find returns first match or undefined. slice doesn't modify."}],
      "JavaScript String": [{heading: "String Basics", content: "Strings are immutable text. Created with quotes (single, double, backticks). Backticks allow templates with ${} interpolation and multiline. Length property. Strings are iterable (for...of).", syntax: "let str1 = 'Hello';\nlet str2 = \"World\";\nlet str3 = `Hello ${str2}`;\n\nstr1.length; // 5\nstr1[0]; // 'H'\n\nfor (let char of str1) {\n  console.log(char);\n}", explanation: "Template literals (backticks) support interpolation and multiline. Strings are immutable - methods return new strings."},{heading: "String Methods", content: "toLowerCase/toUpperCase: change case. trim: remove whitespace. slice/substring: extract portion. indexOf/includes: search. split: create array. replace: substitute text. startsWith/endsWith: check prefix/suffix.", syntax: "let str = '  Hello World  ';\n\nstr.toLowerCase(); // '  hello world  '\nstr.trim(); // 'Hello World'\nstr.slice(2, 7); // 'Hello'\nstr.indexOf('World'); // 8\nstr.includes('llo'); // true\nstr.split(' '); // ['', '', 'Hello', 'World', '', '']\nstr.replace('World', 'JS'); // '  Hello JS  '", explanation: "Methods return new strings, don't modify original. indexOf returns -1 if not found. split creates array."}],
      "JavaScript Date": [{heading: "Date Basics", content: "Date object works with dates and times. new Date() creates date. Can pass timestamp, date string, or year/month/day. Month is 0-indexed (0 = January). getTime() returns timestamp.", syntax: "let now = new Date();\nlet date = new Date('2024-01-15');\nlet specific = new Date(2024, 0, 15);\n\nnow.getTime(); // timestamp\nnow.getFullYear(); // 2024\nnow.getMonth(); // 0-11\nnow.getDate(); // 1-31\nnow.getDay(); // 0-6 (0=Sunday)", explanation: "Month is 0-indexed but date is 1-indexed. getDay() returns day of week. Date is mutable - setters modify the object."},{heading: "Date Methods", content: "Getters: getFullYear, getMonth, getDate, getDay, getHours, getMinutes, getSeconds. Setters: setFullYear, setMonth, etc. toISOString: ISO format. toDateString: readable date.", syntax: "let date = new Date();\ndate.setFullYear(2025);\ndate.setMonth(11); // December\ndate.toISOString(); // '2025-12-...'", explanation: "Setters modify date in place. toISOString for storage. Use libraries like date-fns or day.js for complex operations."}],
      "JavaScript Math": [{heading: "Math Object", content: "Math is built-in object with mathematical functions. Properties: PI, E. Methods: round, floor, ceil (rounding), abs (absolute), pow (power), sqrt (square root), random (0-1), min/max, trigonometric functions.", syntax: "Math.PI; // 3.14159...\nMath.E; // 2.71828...\n\nMath.round(4.7); // 5\nMath.floor(4.7); // 4\nMath.ceil(4.1); // 5\nMath.abs(-5); // 5\nMath.pow(2, 3); // 8\nMath.sqrt(16); // 4\nMath.random(); // 0.0 to 0.999...\nMath.max(1, 5, 3); // 5", explanation: "Math.random() gives 0 ≤ x < 1. For range: Math.floor(Math.random() * (max - min + 1)) + min. Math methods don't modify arguments."}],
      "JavaScript Number": [{heading: "Number Methods", content: "Number object wraps primitive numbers. Methods: toFixed (decimal places), toPrecision (significant digits), toString (convert to string, with base). Properties: MAX_VALUE, MIN_VALUE, NaN, POSITIVE_INFINITY.", syntax: "let num = 123.456;\nnum.toFixed(2); // '123.46'\nnum.toPrecision(4); // '123.5'\nnum.toString(); // '123.456'\n\nNumber.MAX_VALUE;\nNumber.isNaN(NaN); // true\nNumber.isInteger(5); // true", explanation: "toFixed/toPrecision return strings. Number.isNaN checks if NaN (unlike global isNaN). Number.parseInt/parseFloat parse strings."}],
      "JavaScript Boolean": [{heading: "Boolean Type", content: "Boolean has two values: true and false. Boolean() converts values. Falsy: false, 0, '', null, undefined, NaN. All else truthy including '0', 'false', [], {}. Logical operators work with booleans.", syntax: "let bool = true;\n\nBoolean(1); // true\nBoolean(0); // false\nBoolean(''); // false\nBoolean('0'); // true\n!!value; // converts to boolean", explanation: "Empty strings/arrays/objects behave differently. '' is falsy, [] and {} are truthy. Use !! to convert to boolean explicitly."}],
      "JavaScript JSON": [{heading: "JSON Format", content: "JSON (JavaScript Object Notation) is text format for data exchange. Subset of JavaScript literals. Keys must be double-quoted strings. Values: string, number, boolean, null, object, array. No functions, undefined, dates.", syntax: "{\n  \"name\": \"John\",\n  \"age\": 30,\n  \"active\": true,\n  \"tags\": [\"js\", \"web\"],\n  \"address\": {\n    \"city\": \"NYC\"\n  }\n}", explanation: "JSON is language-independent text format. Strict syntax: double quotes, no trailing commas, no comments."},{heading: "JSON Methods", content: "JSON.stringify: converts JS value to JSON string. JSON.parse: converts JSON string to JS value. stringify takes optional replacer and space for formatting. parse throws on invalid JSON.", syntax: "let obj = {name: 'John', age: 30};\nlet json = JSON.stringify(obj);\n// '{\"name\":\"John\",\"age\":30}'\n\nlet parsed = JSON.parse(json);\n\nlet pretty = JSON.stringify(obj, null, 2);", explanation: "stringify converts JS to JSON text. parse converts JSON text to JS. Third argument to stringify is indentation for readability."}],
      "JavaScript RegExp": [{heading: "Regular Expressions", content: "RegExp tests and matches patterns in strings. Created with // or new RegExp(). Flags: i (case-insensitive), g (global), m (multiline). Methods: test (boolean), exec (details), String methods: match, replace, search.", syntax: "let regex = /hello/i;\nregex.test('Hello'); // true\n\nlet pattern = /\\d+/g;\n'a1b2c3'.match(pattern); // ['1', '2', '3']\n\n'hello world'.replace(/world/, 'JS');\n'test123'.search(/\\d/); // 4", explanation: "/ / creates regex literal. \\ escapes special chars. test checks match. match extracts matches. replace substitutes."}],
      "Mouse Events": [{heading: "Mouse Event Types", content: "mousedown: button pressed. mouseup: button released. click: full click (down+up). dblclick: double click. mouseover: pointer enters element. mouseout: pointer leaves. mousemove: pointer moves. contextmenu: right-click. Events bubble up DOM tree.", syntax: "element.addEventListener('click', function(event) {\n  console.log('Clicked at', event.clientX, event.clientY);\n});\n\nelement.onmouseenter = function() {\n  this.style.background = 'yellow';\n};", explanation: "Event object contains mouse position (clientX/Y, pageX/Y), button clicked, modifiers (ctrl, shift). click = mousedown + mouseup on same element."},{heading: "Event Properties", content: "event.target: element that triggered. event.currentTarget: element with listener. event.clientX/Y: viewport coordinates. event.pageX/Y: document coordinates. event.button: which button (0=left, 1=middle, 2=right). event.ctrlKey, shiftKey, altKey, metaKey: modifier keys.", syntax: "element.addEventListener('click', (e) => {\n  console.log('Target:', e.target);\n  console.log('Position:', e.clientX, e.clientY);\n  console.log('Button:', e.button);\n  if (e.ctrlKey) console.log('Ctrl held');\n});", explanation: "target is where event originated. currentTarget is where listener attached. Coordinates relative to viewport or document."}],
      "Moving the Mouse": [{heading: "mouseover vs mouseenter", content: "mouseover: fires when entering element or its children (bubbles). mouseout: fires when leaving element or its children. mouseenter: fires only when entering element (doesn't bubble). mouseleave: fires only when leaving element. enter/leave are simpler for hover effects.", syntax: "element.addEventListener('mouseenter', () => {\n  console.log('Entered');\n});\n\nelement.addEventListener('mouseleave', () => {\n  console.log('Left');\n});", explanation: "mouseenter/mouseleave don't trigger on child elements. mouseover/mouseout do. Use enter/leave for cleaner hover logic."},{heading: "mousemove", content: "mousemove fires when pointer moves within element. Fires frequently, so use throttling for performance. Gives real-time pointer position. Used for drag, drawing, custom cursors, hover effects.", syntax: "element.addEventListener('mousemove', (e) => {\n  const x = e.clientX;\n  const y = e.clientY;\n  console.log(`Position: ${x}, ${y}`);\n});", explanation: "Fires many times per second. Throttle or debounce handlers for heavy operations. Get position from event.clientX/Y."}],
      "Drag and Drop with Mouse Events": [{heading: "Implementing Drag", content: "Drag uses mousedown, mousemove, mouseup. mousedown starts drag (track that dragging started). mousemove updates position while dragging. mouseup ends drag. Calculate offset from mouse to element edge. Update element position based on mouse.", syntax: "let dragging = false;\nlet offsetX, offsetY;\n\nelement.onmousedown = (e) => {\n  dragging = true;\n  offsetX = e.clientX - element.offsetLeft;\n  offsetY = e.clientY - element.offsetTop;\n};\n\ndocument.onmousemove = (e) => {\n  if (dragging) {\n    element.style.left = (e.clientX - offsetX) + 'px';\n    element.style.top = (e.clientY - offsetY) + 'px';\n  }\n};\n\ndocument.onmouseup = () => {\n  dragging = false;\n};", explanation: "Track drag state (boolean). Store offset on mousedown. Update position on mousemove. Clear state on mouseup. Attach move/up to document to track outside element."}],
      "Keyboard Events": [{heading: "keydown and keyup", content: "keydown: fires when key pressed (repeats if held). keyup: fires when key released. event.key: key value ('a', 'Enter', 'ArrowUp'). event.code: physical key ('KeyA', 'Enter', 'ArrowUp'). event.ctrlKey, shiftKey, altKey, metaKey: modifiers. Use key for character, code for position.", syntax: "document.addEventListener('keydown', (e) => {\n  console.log('Key:', e.key);\n  console.log('Code:', e.code);\n  \n  if (e.key === 'Enter') {\n    console.log('Enter pressed');\n  }\n  \n  if (e.ctrlKey && e.key === 's') {\n    e.preventDefault(); // Prevent save\n    console.log('Save shortcut');\n  }\n});", explanation: "keydown repeats while held. keyup fires once on release. Use e.preventDefault() to stop default actions (like form submit). Check modifiers for shortcuts."}],
      "Scrolling Events": [{heading: "scroll Event", content: "scroll fires when element or window scrolls. Fires frequently during scrolling. Get scroll position with scrollY/scrollX (window) or scrollTop/scrollLeft (elements). Use for infinite scroll, sticky headers, scroll animations, lazy loading.", syntax: "window.addEventListener('scroll', () => {\n  const scrolled = window.scrollY;\n  console.log('Scrolled:', scrolled);\n  \n  if (scrolled > 100) {\n    navbar.classList.add('sticky');\n  }\n});\n\nelement.addEventListener('scroll', () => {\n  const atBottom = element.scrollHeight - element.scrollTop === element.clientHeight;\n  if (atBottom) console.log('Reached bottom');\n});", explanation: "scrollY is pixels from top. scrollHeight is total height. scrollTop is current scroll. clientHeight is visible height. Throttle scroll handlers for performance."}]
    }
  }
};
